# Unstructured simplicial meshes

Support for simplicial meshes uses the [https://github.com/jlchan/StartUpDG.jl](StartUpDG.jl) package. These meshes are constructed by specifying a list of vertex coordinates `VX, VY, VZ` and a connectivity matrix `EToV` where `EToV[e,:]` gives the vertices which correspond to element `e`. 

We make a few simplifying assumptions about simplicial meshes:
* meshes consist of a single type of element
* meshes are _conforming_ (e.g., each face of an element is shared with at most one other element). 
* the geometric mapping from reference to physical elements is polynomial (currently, only affine mappings are supported).

## `AbstractMeshData` wrapper type

Simplicial meshes in Trixi are represented using an `AbstractMeshData{Dim, ElemType}` wrapper. For example, `VertexMappedMesh{Dim, Tri} <: AbstractMeshData{Dim, Tri}` describes a mesh whose reference-to-physical mapping can be constructed using only the vertex positions (e.g., an affine simplicial mesh or a bilinear quadrilateral mesh). These quantities are generated by most simplicial mesh generators, and `StartUpDG.jl` includes both simple uniform meshes via `uniform_mesh`, as well as support for triangular meshes constructed using [https://github.com/JuliaGeometry/Triangulate.jl](Triangulate.jl).

The only fields are `md::MeshData`, which contains geometric terms derived from the mapping between the reference and physical elements, and `boundary_faces`, which contains a `Dict` of boundary segment names (symbols) and list of faces which lie on that boundary segment. 

## Variable naming conventions

We use the convention that coordinates on the reference element are ``r`` in 1D, ``r, s`` in 2D, or ``r, s, t`` in 3D. Physical coordinates use the standard conventions ``x``, ``x, y``, and ``x, y, z`` in 1D, 2D, and 3D. 

![Mapping](assets/mapping_diagram.png)

Derivatives of reference coordinates with respect to physical coordinates are abbreviated, e.g., ``\frac{\partial r}{\partial x} = r_x``. Additionally, ``J`` is used to denote the determinant of the Jacobian of the reference-to-physical mapping. 

## Variable meanings and conventions in `StartUpDG.jl`

`StartUpDG.jl` exports structs `RefElemData{Dim, ElemShape, ...}` (which contains data associated with the reference element, such as interpolation points, quadrature rules, face nodes, normals, and differentiation/interpolation/projection matrices) and `MeshData{Dim}` (which contains geometric data associated with a mesh). These are currently used for evaluating DG formulations in a matrix-free fashion. These structs contain fields similar (but not identical) to those in `Globals1D, Globals2D, Globals3D` in the Matlab codes from "Nodal Discontinuous Galerkin Methods" by Hesthaven and Warburton (2007). 

In general, we use the following code conventions:
* variables such as `r, s,...` and `x, y,...` correspond to values at nodal interpolation points. 
* variables ending in `q` (e.g., `rq, sq,...` and `xq, yq,...`) correspond to values at volume quadrature points. 
* variables ending in `f` (e.g., `rf, sf,...` and `xf, yf,...`) correspond to values at face quadrature points. 
* variables ending in `p` (e.g., `rp, sp,...`)
* `V` matrices correspond to interpolation matrices from nodal interpolation points, e.g., `Vq` interpolates to volume quadrature points, `Vf` interpolates to face quadrature points. 
* geometric quantities in `MeshData` are stored as matrices of dimension ``\text{number of points per element } \times \text{number of elements}``. 

Quantities in `rd::RefElemData`: 
* `rd.Np, rd.Nq, rd.Nf`: the number of nodal interpolation points, volume quadrature points, and face quadrature points on the reference element, respectively. 
* `rd.Vq`: interpolation matrices from values at nodal interpolation points to volume quadrature points
* `rd.wq`: volume quadrature weights on the reference element
* `rd.Vf`: interpolation matrices from values at nodal interpolation points to face quadrature points
* `rd.wf`: a vector containing face quadrature weights on the reference element
* `rd.M`: the quadrature-based mass matrix, computed via `rd.Vq' * diagm(rd.wq) * rd.Vq`.
* `rd.Pq`: a quadrature-based ``L^2`` projection matrix `rd.Pq = rd.M \ rd.Vq' * diagm(rd.wq)` which maps between values at quadrature points and values at nodal points. 
* `Dr, Ds, Dt` matrices are nodal differentiation matrices with respect to the ``r,s,t`` coordinates, e.g., `Dr*f.(r,s)` approximates the derivative of ``f(r,s)`` at nodal points. 

Quantities in `md::MeshData`: 
* `md.xyz` is a tuple of matrices `md.x`, `md.y`, `md.z`, where column `e` contains coordinates of physical interpolation points. 
* `md.xyzq` is a tuple of matrices `md.xq`, `md.yq`, `md.zq`, where column `e` contains coordinates of physical quadrature points. 
* `md.rxJ, md.sxJ, ...` are matrices where column `e` contains values of ``J\frac{\partial r}{\partial x}``, ``J\frac{\partial s}{\partial x}``, etc. at nodal interpolation points on the element `e`.
* `md.J` is a matrix where column `e` contains values of ``J`` at nodal interpolation points.
* `md.sJ` is a matrix where column `e` contains values of the face Jacobian (e.g., determinant of the geometric mapping between a physical face and a reference face) at face quadrature points.
* `md.nxJ, md.nyJ, ...` are matrices where column `e` contains values of components of the unit normal scaled by the face Jacobian `md.sJ` at face quadrature points.

For more details, please see the [https://jlchan.github.io/StartUpDG.jl/dev/](StartUpDG.jl docs). 

